package F_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {
		/* 
		 1. 상속(is a : ~은 ~이다.)
		   - 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		   - 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		   - 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써주기만 하면 된다.
		   
		   class Child extends Parent{
		   	.....
		   }
		   
		   - 상속해주는 클래스를 '조상클래스', 상혹받는 클래스를 '자손클래스'라 한다.
		     : 조상클래스 - 부무클래스, 상위클래스, 기반클래스
		     : 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
		     
		   - 맴버만 상속받는다.
		   - 자손클래스의 맴버의 개수는 조상클래스보다 같거나 많다.
		   
		   
		 2. 포함(has a :~은 ~을 포함하고 있다.)
		   - 상속이외에 클래스를 재사용하는 방법
		   - 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
		   
		 3. 단일상속
		   - 자바에서는 단일상속(두개이상은 불가능)만 가능하다.
		     class TVCR extends TV, VCR{// 불가능
		   - Tv와 VCR에 동일한 맴버가 있을깨 어떤것을 상속받을지 알 수 없다.
		   - VCR의 맴버명을 바꾼다면 그동안 VCR의 맴버를 사용하던 부분들을 모두 수정해 주어야 한다.
		   - 클래스간의 관계가 보다 명확해지고 코들르 더욱 신뢰할 수 있다.
		 
		 4.Object클래스 (모든 클래스의 조상)
		   - 모든 클래스의 상속 계층도의 가장 위에 위치하는 조상 클래스이다.
		   - 다른 클래스로부터 상속받지 않는 클래스들은 자동적으로 Object클래스를 상속받는다.
		   
		    calss Tv{
		    }
		   =>컴파일후
		   class Tv extend Object{
		   
		   }
		   - toString()나 equals()와 같은 메서드를 따로 정의하지 않고 사용할 수 있는것은
		     object클래스에 정의된 것들이기 때문이다.
		   
		  5.오버라이드(override)
		    - 조상클래스로부터 상속받은 메서드의 내용을 변경하는것.(재정의)하는것
		    - 오버라이드 되기 위한 조건 => 선언부가 일치 해야 한다.
		      : 자손클래스에서 오버라이드 하는 메서드는 조상클래스의 매서드의 명과 동일해야 한다.
		      : 매개변수이 타입과 갯수가 같아야 한다.	
		      : 리턴타입이 같아야 한다.
		      : 접근제어자를 조상클래스보다 좁은 범위로 설정할 수 없다.
		      : 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
		   
		   6. super.
		     - 조상클래스의 맴버와 자손클래스의 맴버가 중복 정의되어 있을때 서로 구분하기 위해 사용
		     - 조상 맴버와 자신의 맴버를 구별하는데 사용한다는 것을 제외하고는 this.과 근본적으로 동일
		     - static메서드에서 사용할 수 없다.(인스턴스가 있어야만 사용할 수 있다.)
		     
		   7. super()- 조상클래스의 생성자를 호출
		   	 - this()와 마찬가지로 super()역시 생성자이다.
		   	 - this()는 같은 클래스의 다른 생성자를 호출 
		   	   super()는 부모클래스의 생성자를 호출
		   	 - 생성자의 첫 줄에는 조상 클래스의 생성자를 호출해야 한다.
		   	    자손 클래스의 맴버가 조상클래스의 맴버를 사용할 수 있으므로 조상의 맴버들이 먼저 초기화 되어야 한다.
		   
		   8. 제어자
		     - 클래스, 변수 메서드의 선언부에 사용된다.
		     - 접근제어자와 그 외 제어자로 나누어진다.
		     - 접근제어자 : private, default, protected, public
		  	 - 그외제어자 : static, final abstract, native...
		     - 접근제어자를 제일 왼쪽에 많이 둔다.
		     - static(클래스의, 공통적인)
		     	: 맴버변수, 메서드, 초기화블럭에 사용된다.
		     	: static 변수
		     	  -> 모든인스턴스에서 공통적으로 사용한다.
		     	  -> 인스턴스를 생성하지 않고도 호출할 수 있다.
		     	  -> 클래스가 메모리에 로드될때 생성된다.
		     	: static 메서드
		     	  -> 인스턴스 생성없이 사용가능
		     	  -> 클래스 메서드 내에서 인스턴스 멤버를 호출할 수 없다.
		     - final(마지막의 변경할수 없는)
		     	: 변수에 사용시 변경할 수 없는 상수가 된다.
		     	: 오버라이드 할 수 없다.
		     	: 클래스에 사용시 상속할 수 없는 클래스가 된다.
		     
		     - abstract(추상의,미완성된)
		     	: 메서드와 클래스에만 사용가능
		     	: 메서드에 사용시 구현부는 작성하지 않는다.
		     	abstract void method();
		     
		     9. 접근제어자
		       - private : 같은 클래스 내에서 접근가능.
		       - default 같은 패키지 내에서 접근가능.
		       - protected 같은 패키지+ 다른 패키지의 자손클래스에서 접근가능.
		       - public 접근제한이 없다.
		       - 클래스에는 default, public사용가능
		    
		     10. 캡슐화
		       - 접근제어자를 사용하는 이유
		         : 외부로 부터 데이터를 보호하기 위한 목적
		         : 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해 사용
		     
		     11. 다형성(polymorphism)
		       - 여라가지 형태를 가질 수 있는 능력
		       - 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
		     	 Car c = new FireCar();
		     	 Car c - new Ambulance();
		       - 부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		    
		     12. 참조변수의 형변환 (상속)
		       - 서로 상속관계에 있는 클래스 에서만 형변환이 가능하다. 	
		       - 자손타입->부모타입(up-casting) : 형변환 생략 가능
		       - 부모타입->자손타입(down-casting): 형변환 생략 불가  
		   	
		   	 13. instansof 
		   	   - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
		   	   - 연산결과가 true이면 참조변수가 검사한 타입으로 형변환이 가능하다.
		   	   - 클래스메서드와 클래스 변수는 참조변후의 타입에 영향을 받는다.
		   	   - 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다. 
		   	   
		 	 14. 매개변수의 다형성
		 	   - 참조변수의 다형적인 특징은 매서드의 매개변수에도 적용된다.
		 	
		 	 15. 여러객체배열, Vector
		 	   - 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		 	   - Vector
		 	     : 배열을 사용할 경우 전체 크기를 한번 정하면 변경할 수 없다.
		 	         이를 Vector클래스를 이용하여 해결할 수 있다.
		 	     : 동적으로 크기가 관리되는 객체배열 이라고 할 수 있다.
		 	     
		 	     Vector v = new Vector();
		 	     Vector() : 10개의 객체를 저장할수 있는 Vector인스턴스를 생성한다.
		 	     add()	  : Vector에 객체를 추가한다.
		 	     remove() : Vector에 객체를 삭제한다.
		 	     isEmpty(): Vector에 객체를 가지고 있는지 확인
		 	     Object get()(int index): index번째 객체를 반환한다.
		 	     int size(): Vector에 객체가 저장된 개수를 반환한다.
		 	     
		 	 16. 추상클래스(abstract class)
		 	    - 미완성된 클래스 : 미완성된 메서드를 가지고 있다는 의미
		 	    - 구성 
		 	    	abstract class 클래스명{
		 	    	
		 	    	}
		 	    - 추상메서드 
		 	      : 메서드는 선언부와 구현부로 구성되어있다.
		 	      : 추상메서드는 선언부만 작성되어 있고 구현부는 작성되지 않은 메서드를 의미한다.
		 	      abstract 리턴타입 메서드명 ();
		 	    - 추상클래스로부터 상속받는 자손 클래스를 오버라이딩을 통해 조상인 클래스의 추상 메서드를 구현해 주면된다.
		 	    
		 	    
		 	 17. 인터페이스 
		 	   - 일종의 추상클래스 이지만 추상메서드와 상수만을 맴버로 가진다.
		 	   - 인터페이스의 작성
		 	     interface  인터페이스명 {
		 	     	public static final 변수타입 변수명 = 값;
		 	     	public abstract 반환타입 메서드명(매개변수타입 명,...);
		 	     	
		 	     } 
		 	     
		 	     : 모든 멤버변수는 public static final 이어야 한다. => 생략할 수 있다.
		 	     : 모든 메서드는 public abstract 이어야 한다.=>생략할 수 있다.
		 	   
		 	   - 인터페이스의 상속
		 	     : 인터페이스는 인터페이스만 상속 받을수 있다.
		 	       => 구현된 메서드를 상혹받으면 더이상 인터페이스가 아니게 된다.
		 	     : 인터페이스는 다중상속 가능하다.
		 	     : Object와 같은 최고 조상은 없다.
		 	    
		 	   - 인터페이스의 구현
		 	     : 자체로는 인스턴스를 생성할 수 없다.
		 	     : 자신이 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다.
		 	     : 클래스의 확장(extends), 인터페이스의 구현(implements)
		 	     : ~able 
		 	       => Movable
		 	       => IMove => IMoveImpl
		 	   - 인터페이스의 다형성
		 	     : 인터페이스 타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
		 	  
		 	   - 인터페이스의 장점
		 	     : 개발시간을 단축할 수 있다. 
		 	     : 표준화가 가능하다.
		 	     : 서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
		 	     : 7-26예제 꼭 해보세요~
		 	     
		 	 18. 내부클래스(inner class)
		 	   - 내부클래스란 ?
		 	     : 클래스내에 선언된 클래스
		 	     : 서로 쉽게 접근할 수 있고 외부에서 볼때 불필요한 클래스를 감춤으로 
		 	     	복잡성을 줄일 수 있다.
		 	   - 인터페이스의 이해
		 	     : 클래스를 사용한 쪽(user)과 클래스를 제공하는 쪽(provider)이 있다.
		 	       A - I - B
		 	       
		 	   - 인스턴스 클래스
		 	     : 외부클래스의 인스턴스 멤버들과 관련된 작업을 수행한다.
		 	   - 스태틱클래스
		 	     : 외부 클래스의 클래스멤버들과 관련된 작업을 수행, 클래스 메서드와 관련된 작업을 수행한다.
		 	   - 지역클래스
		 	     : 외부 클래스의 메서드나 초기화블럭 안에 선언, 선언 영역 내에서만 사용 가능
		 	   - 익명클래스     
		 	     : 클래스의 선언과 객체의 생성을 동시에 진행한다.
		 	     : 이름이 없는 클래스(일회용)      
		 	     
		 	     
		 	     
		 	     
		 	     
		 	       
		 	     
		 	     
		 	   
		 */
		
	}

}
